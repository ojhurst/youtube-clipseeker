#!/usr/bin/env python3
"""
YouTube Transcript Fetcher
Uses youtube-transcript-api for reliable transcript extraction
"""

import sys
import json
import ssl
import certifi
import os
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse

# Fix SSL certificate issues on macOS
os.environ['SSL_CERT_FILE'] = certifi.where()
os.environ['REQUESTS_CA_BUNDLE'] = certifi.where()

# Also set default SSL context
try:
    ssl._create_default_https_context = ssl._create_unverified_context
except:
    pass

try:
    from youtube_transcript_api import YouTubeTranscriptApi
except ImportError:
    print("Installing dependencies...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "youtube-transcript-api", "certifi", "-q"])
    import certifi
    os.environ['SSL_CERT_FILE'] = certifi.where()
    os.environ['REQUESTS_CA_BUNDLE'] = certifi.where()
    from youtube_transcript_api import YouTubeTranscriptApi

class TranscriptHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed = urlparse(self.path)
        
        if parsed.path.startswith('/transcript/'):
            video_id = parsed.path.split('/transcript/')[-1]
            self.handle_transcript(video_id)
        elif parsed.path == '/health':
            self.send_json_response({"status": "ok"})
        else:
            self.send_json_response({"error": "Not found"}, 404)
    
    def do_OPTIONS(self):
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()
    
    def send_json_response(self, data, status=200):
        self.send_response(status)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())
    
    def handle_transcript(self, video_id):
        try:
            # New API in youtube-transcript-api v1.x
            # Use .list() and .fetch() methods
            ytt_api = YouTubeTranscriptApi()
            
            transcript_data = None
            language = 'en'
            is_generated = True
            
            try:
                # Try to get English transcript first using fetch
                transcript_data = ytt_api.fetch(video_id, languages=['en', 'en-US', 'en-GB'])
                language = 'en'
            except Exception as e:
                print(f"No English transcript, trying any language: {e}")
                try:
                    # List available transcripts
                    transcript_list = ytt_api.list(video_id)
                    # Get the first available transcript
                    for transcript in transcript_list:
                        transcript_data = transcript.fetch()
                        language = transcript.language_code
                        is_generated = transcript.is_generated
                        break
                except Exception as e2:
                    print(f"List failed, trying fetch without language: {e2}")
                    # Try without language preference
                    transcript_data = ytt_api.fetch(video_id)
            
            if not transcript_data:
                self.send_json_response({
                    "error": "No transcript available",
                    "videoId": video_id
                }, 404)
                return
            
            segments = []
            for item in transcript_data:
                segments.append({
                    "start": item.start,
                    "duration": item.duration,
                    "end": item.start + item.duration,
                    "text": item.text
                })
            
            print(f"✅ Got {len(segments)} segments for {video_id}")
            
            self.send_json_response({
                "videoId": video_id,
                "language": language,
                "isAutoGenerated": is_generated,
                "transcript": segments
            })
            
        except Exception as e:
            error_msg = str(e)
            print(f"❌ Error for {video_id}: {error_msg}")
            
            # Check for common errors
            if "disabled" in error_msg.lower():
                self.send_json_response({
                    "error": "Transcripts are disabled for this video",
                    "videoId": video_id
                }, 404)
            elif "No transcript" in error_msg or "not find" in error_msg.lower() or "not available" in error_msg.lower():
                self.send_json_response({
                    "error": "No transcript found for this video",
                    "videoId": video_id
                }, 404)
            else:
                self.send_json_response({
                    "error": error_msg,
                    "videoId": video_id
                }, 500)
    
    def log_message(self, format, *args):
        print(f"[Transcript API] {args[0]}")

def run_server(port=3003):
    server = HTTPServer(('localhost', port), TranscriptHandler)
    print(f"✅ Transcript API running at http://localhost:{port}")
    print("   Endpoints:")
    print(f"   - GET /transcript/{{videoId}} - Get transcript for a video")
    print(f"   - GET /health - Health check")
    server.serve_forever()

if __name__ == '__main__':
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 3003
    run_server(port)
