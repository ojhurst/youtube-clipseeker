// Transcript extraction service
// Tries client-side fetching first (uses user's IP), falls back to server

import { getYouTubeThumbnail, formatDuration } from './youtubeUtils'
import { processVideoClient, getVideoInfo as getVideoInfoClient } from './clientTranscript'

// Auto-detect API base URL for server fallback
const getApiBase = () => {
  if (import.meta.env.VITE_BACKEND_URL) {
    return import.meta.env.VITE_BACKEND_URL
  }
  if (import.meta.env.PROD) {
    return '/api'
  }
  return import.meta.env.VITE_API_URL || 'http://localhost:3002/api'
}

const API_BASE = getApiBase()

// Prefer client-side fetching (uses user's IP, avoids cloud IP blocks)
const PREFER_CLIENT_SIDE = true

console.log(`ðŸ“¡ API Base: ${API_BASE}`)
console.log(`ðŸŒ Client-side fetching: ${PREFER_CLIENT_SIDE ? 'enabled' : 'disabled'}`)

// Helper to delay execution
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms))

// Parse error messages for better UX
const parseErrorMessage = (error) => {
  const msg = error.message || String(error)
  
  if (msg.includes('IP') || msg.includes('blocked') || msg.includes('too many requests')) {
    return 'Rate limited by YouTube. Try again in a few minutes.'
  }
  if (msg.includes('disabled')) {
    return 'Transcripts are disabled for this video'
  }
  if (msg.includes('No transcript') || msg.includes('No captions') || msg.includes('not find') || msg.includes('not available')) {
    return 'No transcript available for this video'
  }
  if (msg.includes('fetch') || msg.includes('network') || msg.includes('ECONNREFUSED')) {
    return 'Cannot connect to transcript server. Make sure the backend is running.'
  }
  
  return msg
}

// Fetch video info from multiple sources
export const fetchVideoInfo = async (videoId) => {
  try {
    const response = await fetch(`${API_BASE}/video-info/${videoId}`)
    
    if (response.ok) {
      const data = await response.json()
      return {
        id: videoId,
        title: data.title,
        channelName: data.author,
        channelUrl: data.authorUrl,
        thumbnail: data.thumbnail || getYouTubeThumbnail(videoId, 'hqdefault'),
        thumbnailHigh: getYouTubeThumbnail(videoId, 'maxresdefault')
      }
    }
  } catch (error) {
    console.warn('API failed for video info:', error)
  }
  
  // Fallback: Try oEmbed directly
  try {
    const oembedUrl = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`
    const response = await fetch(oembedUrl)
    if (response.ok) {
      const data = await response.json()
      return {
        id: videoId,
        title: data.title,
        channelName: data.author_name,
        thumbnail: getYouTubeThumbnail(videoId, 'hqdefault'),
        thumbnailHigh: getYouTubeThumbnail(videoId, 'maxresdefault')
      }
    }
  } catch (error) {
    console.warn('oEmbed failed:', error)
  }
  
  // Final fallback
  return {
    id: videoId,
    title: `Video ${videoId}`,
    channelName: 'Unknown Channel',
    thumbnail: getYouTubeThumbnail(videoId, 'hqdefault')
  }
}

// Fetch transcript from API with retry
export const fetchTranscript = async (videoId, maxRetries = 2) => {
  let lastError = null
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      if (attempt > 0) {
        const waitTime = Math.pow(2, attempt) * 1000
        console.log(`Retry ${attempt} for ${videoId} after ${waitTime}ms`)
        await delay(waitTime)
      }
      
      const response = await fetch(`${API_BASE}/transcript/${videoId}`)
      const data = await response.json()
      
      if (!response.ok) {
        const errorMsg = data.error || 'Failed to fetch transcript'
        // Don't retry for non-recoverable errors
        if (errorMsg.includes('disabled') || errorMsg.includes('No transcript') || 
            errorMsg.includes('No captions') || errorMsg.includes('not available')) {
          throw new Error(errorMsg)
        }
        lastError = new Error(errorMsg)
        continue
      }
      
      return {
        transcript: data.transcript,
        duration: data.lengthSeconds || 0,
        language: data.language,
        isAutoGenerated: data.isAutoGenerated,
        title: data.title,
        author: data.author
      }
    } catch (error) {
      lastError = error
      // Don't retry for non-recoverable errors
      if (error.message.includes('disabled') || error.message.includes('No transcript') ||
          error.message.includes('No captions') || error.message.includes('not available')) {
        throw error
      }
    }
  }
  
  throw lastError || new Error('Failed to fetch transcript after retries')
}

// Process a single video and return full video data with transcript
export const processVideo = async (videoId, onProgress) => {
  // Try client-side first (uses user's IP - more reliable)
  if (PREFER_CLIENT_SIDE) {
    try {
      if (onProgress) onProgress('Fetching transcript (client-side)...')
      const result = await processVideoClient(videoId)
      console.log(`âœ… Client-side success for ${videoId}`)
      return result
    } catch (clientError) {
      console.warn(`âš ï¸ Client-side failed for ${videoId}:`, clientError.message)
      // Fall through to server-side
    }
  }

  // Server-side fallback
  try {
    if (onProgress) onProgress('Fetching video info...')
    
    const videoInfo = await fetchVideoInfo(videoId)
    
    if (onProgress) onProgress('Fetching transcript (server)...')
    
    const response = await fetch(`${API_BASE}/transcript/${videoId}`)
    const data = await response.json()
    
    if (!response.ok) {
      const error = new Error(parseErrorMessage(data.error || 'Failed to fetch transcript'))
      error.videoTitle = videoInfo.title
      error.videoId = videoId
      throw error
    }
    
    let duration = data.lengthSeconds || 0
    if (!duration && data.transcript && data.transcript.length > 0) {
      const lastSegment = data.transcript[data.transcript.length - 1]
      duration = Math.ceil(lastSegment.start + (lastSegment.duration || 0))
    }
    
    return {
      id: videoId,
      title: data.title || videoInfo.title,
      channelName: data.author || videoInfo.channelName,
      thumbnail: getYouTubeThumbnail(videoId, 'hqdefault'),
      thumbnailHigh: getYouTubeThumbnail(videoId, 'maxresdefault'),
      duration: duration,
      durationFormatted: formatDuration(duration),
      transcript: data.transcript,
      language: data.language,
      isAutoGenerated: data.isAutoGenerated,
      processedAt: Date.now()
    }
  } catch (error) {
    const enhancedError = new Error(parseErrorMessage(error.message))
    enhancedError.videoTitle = error.videoTitle
    enhancedError.videoId = videoId
    throw enhancedError
  }
}

// Process multiple videos with progress callback
export const processVideos = async (videoIds, onProgress, onVideoComplete, onVideoError) => {
  const results = {
    success: [],
    failed: []
  }

  let consecutiveErrors = 0
  const MAX_CONSECUTIVE_ERRORS = 5

  for (let i = 0; i < videoIds.length; i++) {
    const videoId = videoIds[i]
    
    // Back off if getting rate limited
    if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
      console.warn(`${consecutiveErrors} consecutive errors, waiting 10 seconds...`)
      if (onProgress) {
        onProgress({
          current: i + 1,
          total: videoIds.length,
          currentId: videoId,
          status: 'Rate limited - waiting 10 seconds...'
        })
      }
      await delay(10000)
      consecutiveErrors = 0
    }
    
    try {
      if (onProgress) {
        onProgress({
          current: i + 1,
          total: videoIds.length,
          currentId: videoId
        })
      }

      // Get video info first
      const videoInfo = await fetchVideoInfo(videoId)
      
      if (onProgress) {
        onProgress({
          current: i + 1,
          total: videoIds.length,
          currentId: videoId,
          currentTitle: videoInfo.title
        })
      }

      const video = await processVideo(videoId)
      results.success.push(video)
      consecutiveErrors = 0
      
      if (onVideoComplete) {
        onVideoComplete(video)
      }
    } catch (error) {
      console.error(`Failed to process video ${videoId}:`, error)
      
      if (error.message.includes('Rate limited') || error.message.includes('IP')) {
        consecutiveErrors++
      } else {
        consecutiveErrors = 0
      }
      
      // Get video info for display
      let videoTitle = error.videoTitle
      let channelName = null
      
      if (!videoTitle) {
        try {
          const info = await fetchVideoInfo(videoId)
          videoTitle = info.title
          channelName = info.channelName
        } catch (e) {
          // Ignore
        }
      }
      
      const failedVideo = {
        id: videoId,
        title: videoTitle || `Video ${videoId}`,
        channelName: channelName,
        error: error.message
      }
      
      results.failed.push(failedVideo)
      
      if (onVideoError) {
        onVideoError(failedVideo)
      }
    }

    // Delay between videos
    if (i < videoIds.length - 1) {
      const baseDelay = 500
      const errorDelay = consecutiveErrors > 0 ? consecutiveErrors * 1000 : 0
      await delay(baseDelay + errorDelay)
    }
  }

  return results
}
