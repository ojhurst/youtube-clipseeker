import { create } from 'zustand'
import { openDB } from 'idb'
import { supabase, isSupabaseConfigured } from '../lib/supabase'

const DB_NAME = 'clipseeker-db'
const DB_VERSION = 1

// IndexedDB initialization
const initIndexedDB = async () => {
  return openDB(DB_NAME, DB_VERSION, {
    upgrade(db) {
      if (!db.objectStoreNames.contains('videos')) {
        const videoStore = db.createObjectStore('videos', { keyPath: 'id' })
        videoStore.createIndex('channelId', 'channelId')
        videoStore.createIndex('addedAt', 'addedAt')
      }
      if (!db.objectStoreNames.contains('channels')) {
        db.createObjectStore('channels', { keyPath: 'id' })
      }
      if (!db.objectStoreNames.contains('failedVideos')) {
        db.createObjectStore('failedVideos', { keyPath: 'id' })
      }
    }
  })
}

// Storage abstraction layer
const storage = {
  // Videos
  async getAllVideos() {
    if (isSupabaseConfigured()) {
      const { data, error } = await supabase
        .from('videos')
        .select('*')
        .order('created_at', { ascending: false })
      if (error) throw error
      return data.map(v => ({
        ...v,
        channelId: v.channel_id,
        channelName: v.channel_name,
        thumbnailHigh: v.thumbnail_high,
        durationFormatted: v.duration_formatted,
        isAutoGenerated: v.is_auto_generated,
        addedAt: new Date(v.created_at).getTime()
      }))
    }
    return null // Will use IndexedDB
  },

  async putVideo(video, db) {
    if (isSupabaseConfigured()) {
      const { error } = await supabase.from('videos').upsert({
        id: video.id,
        title: video.title,
        channel_id: video.channelId,
        channel_name: video.channelName,
        thumbnail: video.thumbnail,
        thumbnail_high: video.thumbnailHigh,
        duration: video.duration || 0,
        duration_formatted: video.durationFormatted,
        language: video.language,
        is_auto_generated: video.isAutoGenerated,
        transcript: video.transcript,
        processed_at: video.processedAt ? new Date(video.processedAt).toISOString() : null
      })
      if (error) throw error
      return
    }
    await db.put('videos', video)
  },

  async deleteVideo(videoId, db) {
    if (isSupabaseConfigured()) {
      const { error } = await supabase.from('videos').delete().eq('id', videoId)
      if (error) throw error
      return
    }
    await db.delete('videos', videoId)
  },

  // Channels
  async getAllChannels() {
    if (isSupabaseConfigured()) {
      const { data, error } = await supabase.from('channels').select('*')
      if (error) throw error
      return data.map(c => ({
        ...c,
        subscriberCount: c.subscriber_count,
        lastProcessed: new Date(c.updated_at).getTime()
      }))
    }
    return null
  },

  async putChannel(channel, db) {
    if (isSupabaseConfigured()) {
      const { error } = await supabase.from('channels').upsert({
        id: channel.id,
        name: channel.name,
        identifier: channel.identifier,
        subscriber_count: channel.subscriberCount,
        thumbnail: channel.thumbnail,
        url: channel.url
      })
      if (error) throw error
      return
    }
    await db.put('channels', channel)
  },

  // Failed Videos
  async getAllFailedVideos() {
    if (isSupabaseConfigured()) {
      const { data, error } = await supabase.from('failed_videos').select('*')
      if (error) throw error
      return data.map(v => ({
        ...v,
        channelId: v.channel_id,
        channelName: v.channel_name,
        addedAt: new Date(v.created_at).getTime()
      }))
    }
    return null
  },

  async putFailedVideo(video, db) {
    if (isSupabaseConfigured()) {
      const { error } = await supabase.from('failed_videos').upsert({
        id: video.id,
        title: video.title,
        channel_id: video.channelId,
        channel_name: video.channelName,
        error: video.error
      })
      if (error) throw error
      return
    }
    await db.put('failedVideos', video)
  },

  async deleteFailedVideo(videoId, db) {
    if (isSupabaseConfigured()) {
      const { error } = await supabase.from('failed_videos').delete().eq('id', videoId)
      if (error) throw error
      return
    }
    await db.delete('failedVideos', videoId)
  }
}

export const useStore = create((set, get) => ({
  // Database
  db: null,
  isDBReady: false,
  storageMode: isSupabaseConfigured() ? 'supabase' : 'indexeddb',

  // Videos
  videos: [],
  channels: [],
  failedVideos: [],

  // Processing state
  isProcessing: false,
  processingProgress: { 
    current: 0, 
    total: 0, 
    currentTitle: '', 
    currentId: null,
    phase: 'processing',
    batch: null,
    totalBatches: null,
    successCount: 0,
    failCount: 0,
    lastError: null
  },

  // Search
  searchQuery: '',
  searchResults: [],
  highlightedTimestamp: null,

  // Initialize database
  initializeDB: async () => {
    try {
      let db = null
      let videos = []
      let channels = []
      let failedVideos = []

      if (isSupabaseConfigured()) {
        // Use Supabase
        console.log('ðŸ“¦ Using Supabase storage')
        videos = await storage.getAllVideos() || []
        channels = await storage.getAllChannels() || []
        failedVideos = await storage.getAllFailedVideos() || []
      } else {
        // Use IndexedDB
        console.log('ðŸ“¦ Using IndexedDB storage')
        db = await initIndexedDB()
        videos = await db.getAll('videos')
        channels = await db.getAll('channels')
        failedVideos = await db.getAll('failedVideos')
      }

      // Sort videos by addedAt (newest first)
      videos.sort((a, b) => (b.addedAt || 0) - (a.addedAt || 0))

      set({ db, isDBReady: true, videos, channels, failedVideos })
    } catch (error) {
      console.error('Failed to initialize database:', error)
      // Fallback to IndexedDB if Supabase fails
      if (isSupabaseConfigured()) {
        console.log('Supabase failed, falling back to IndexedDB')
        const db = await initIndexedDB()
        const videos = await db.getAll('videos')
        const channels = await db.getAll('channels')
        const failedVideos = await db.getAll('failedVideos')
        set({ db, isDBReady: true, videos, channels, failedVideos, storageMode: 'indexeddb' })
      }
    }
  },

  // Add a video
  addVideo: async (video) => {
    const { db, videos } = get()
    
    const videoWithMeta = {
      ...video,
      addedAt: Date.now()
    }

    try {
      await storage.putVideo(videoWithMeta, db)
      set({ videos: [videoWithMeta, ...videos.filter(v => v.id !== video.id)] })
    } catch (error) {
      console.error('Failed to add video:', error)
    }
  },

  // Add multiple videos
  addVideos: async (newVideos) => {
    const { db, videos } = get()
    
    const videosWithMeta = newVideos.map(v => ({
      ...v,
      addedAt: Date.now()
    }))

    try {
      for (const video of videosWithMeta) {
        await storage.putVideo(video, db)
      }
      const existingIds = new Set(newVideos.map(v => v.id))
      set({ 
        videos: [...videosWithMeta, ...videos.filter(v => !existingIds.has(v.id))]
      })
    } catch (error) {
      console.error('Failed to add videos:', error)
    }
  },

  // Delete a video
  deleteVideo: async (videoId) => {
    const { db, videos } = get()
    
    try {
      await storage.deleteVideo(videoId, db)
      set({ videos: videos.filter(v => v.id !== videoId) })
    } catch (error) {
      console.error('Failed to delete video:', error)
    }
  },

  // Add channel
  addChannel: async (channel) => {
    const { db, channels } = get()
    
    const channelWithMeta = {
      ...channel,
      lastProcessed: Date.now()
    }

    try {
      await storage.putChannel(channelWithMeta, db)
      set({ channels: [...channels.filter(c => c.id !== channel.id), channelWithMeta] })
    } catch (error) {
      console.error('Failed to add channel:', error)
    }
  },

  // Add failed video
  addFailedVideo: async (video) => {
    const { db, failedVideos } = get()
    
    try {
      await storage.putFailedVideo(video, db)
      set({ failedVideos: [...failedVideos.filter(v => v.id !== video.id), video] })
    } catch (error) {
      console.error('Failed to add failed video:', error)
    }
  },

  // Clear failed videos for a channel
  clearFailedVideos: async (channelId) => {
    const { db, failedVideos } = get()
    
    try {
      for (const video of failedVideos.filter(v => v.channelId === channelId)) {
        await storage.deleteFailedVideo(video.id, db)
      }
      set({ failedVideos: failedVideos.filter(v => v.channelId !== channelId) })
    } catch (error) {
      console.error('Failed to clear failed videos:', error)
    }
  },

  // Clear a single failed video
  clearFailedVideo: async (videoId) => {
    const { db, failedVideos } = get()
    
    try {
      await storage.deleteFailedVideo(videoId, db)
      set({ failedVideos: failedVideos.filter(v => v.id !== videoId) })
    } catch (error) {
      console.error('Failed to clear failed video:', error)
    }
  },

  // Set processing state
  setProcessing: (isProcessing, progress = { 
    current: 0, total: 0, currentTitle: '', currentId: null, 
    phase: 'processing', batch: null, totalBatches: null,
    successCount: 0, failCount: 0, lastError: null 
  }) => {
    set({ isProcessing, processingProgress: progress })
  },

  // Update processing progress
  updateProgress: (progress) => {
    set({ processingProgress: { ...get().processingProgress, ...progress } })
  },

  // Search videos
  search: (query) => {
    const { videos } = get()
    set({ searchQuery: query })

    if (!query.trim()) {
      set({ searchResults: [] })
      return
    }

    const results = []
    const queryLower = query.toLowerCase()

    for (const video of videos) {
      if (!video.transcript) continue

      const matches = []
      for (const segment of video.transcript) {
        if (segment.text.toLowerCase().includes(queryLower)) {
          matches.push({
            ...segment,
            videoId: video.id
          })
        }
      }

      if (matches.length > 0) {
        results.push({
          video,
          matches: matches.slice(0, 5),
          totalMatches: matches.length
        })
      }
    }

    results.sort((a, b) => b.totalMatches - a.totalMatches)
    set({ searchResults: results })
  },

  // Set highlighted timestamp
  setHighlightedTimestamp: (timestamp) => {
    set({ highlightedTimestamp: timestamp })
  },

  // Get video by ID
  getVideo: (videoId) => {
    return get().videos.find(v => v.id === videoId)
  },

  // Get videos by channel
  getVideosByChannel: (channelId) => {
    return get().videos.filter(v => v.channelId === channelId)
  },

  // Get stats
  getStats: () => {
    const { videos, channels, failedVideos } = get()
    
    const totalDuration = videos.reduce((acc, v) => {
      if (v.duration && v.duration > 0) {
        return acc + v.duration
      }
      if (v.transcript && v.transcript.length > 0) {
        const lastSeg = v.transcript[v.transcript.length - 1]
        return acc + (lastSeg.end || lastSeg.start + (lastSeg.duration || 5))
      }
      return acc
    }, 0)
    
    return {
      totalVideos: videos.length,
      totalChannels: channels.length,
      totalFailed: failedVideos.length,
      totalDuration
    }
  }
}))
