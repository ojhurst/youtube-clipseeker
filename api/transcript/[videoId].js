// Vercel Serverless Function for fetching YouTube transcripts
// This uses the YouTube caption API directly

export const config = {
  runtime: 'edge',
}

export default async function handler(request) {
  const url = new URL(request.url)
  const videoId = url.pathname.split('/').pop()

  if (!videoId || videoId.length !== 11) {
    return new Response(
      JSON.stringify({ error: 'Invalid video ID' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    )
  }

  try {
    // First, get video info from oEmbed
    const videoInfo = await fetchVideoInfo(videoId)

    // Try to get transcript using YouTube's timedtext API
    const transcript = await fetchTranscript(videoId)

    if (!transcript || transcript.length === 0) {
      return new Response(
        JSON.stringify({ 
          error: 'No transcript available for this video',
          videoId,
          ...videoInfo
        }),
        { status: 404, headers: corsHeaders() }
      )
    }

    return new Response(
      JSON.stringify({
        videoId,
        ...videoInfo,
        language: 'en',
        isAutoGenerated: true,
        transcript
      }),
      { status: 200, headers: corsHeaders() }
    )

  } catch (error) {
    console.error('Transcript fetch error:', error)
    return new Response(
      JSON.stringify({ 
        error: error.message || 'Failed to fetch transcript',
        videoId
      }),
      { status: 500, headers: corsHeaders() }
    )
  }
}

function corsHeaders() {
  return {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
  }
}

async function fetchVideoInfo(videoId) {
  try {
    const response = await fetch(
      `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`
    )
    if (response.ok) {
      const data = await response.json()
      return {
        title: data.title,
        author: data.author_name,
        authorUrl: data.author_url,
        thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`
      }
    }
  } catch (e) {
    console.warn('Failed to fetch video info:', e)
  }
  return {
    title: `Video ${videoId}`,
    author: 'Unknown',
    thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`
  }
}

async function fetchTranscript(videoId) {
  // Method 1: Try to get transcript list from video page
  const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`
  
  try {
    const response = await fetch(videoPageUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        'Accept-Language': 'en-US,en;q=0.9',
      }
    })
    
    if (!response.ok) {
      throw new Error(`Failed to fetch video page: ${response.status}`)
    }

    const html = await response.text()
    
    // Extract caption track URL from ytInitialPlayerResponse
    const captionUrlMatch = html.match(/"captionTracks":\s*\[(.*?)\]/s)
    
    if (!captionUrlMatch) {
      // Try alternative pattern
      const altMatch = html.match(/playerCaptionsTracklistRenderer.*?"captionTracks":\s*\[(.*?)\]/s)
      if (!altMatch) {
        throw new Error('No captions found for this video')
      }
    }

    // Parse caption tracks
    let captionTracksJson = captionUrlMatch ? captionUrlMatch[1] : null
    
    if (captionTracksJson) {
      // Find English caption URL
      const baseUrlMatch = captionTracksJson.match(/"baseUrl":\s*"([^"]+)"/)
      
      if (baseUrlMatch) {
        let captionUrl = baseUrlMatch[1].replace(/\\u0026/g, '&')
        
        // Fetch the caption XML
        const captionResponse = await fetch(captionUrl)
        if (captionResponse.ok) {
          const captionXml = await captionResponse.text()
          return parseTranscriptXml(captionXml)
        }
      }
    }

    throw new Error('Could not extract caption URL')
    
  } catch (error) {
    console.error('Transcript extraction error:', error)
    throw error
  }
}

function parseTranscriptXml(xml) {
  const segments = []
  
  // Parse <text start="..." dur="...">content</text> elements
  const textRegex = /<text start="([^"]+)" dur="([^"]+)"[^>]*>([^<]*)<\/text>/g
  let match

  while ((match = textRegex.exec(xml)) !== null) {
    const start = parseFloat(match[1])
    const duration = parseFloat(match[2])
    let text = match[3]
    
    // Decode HTML entities
    text = text
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/\n/g, ' ')
      .trim()

    if (text) {
      segments.push({
        start,
        duration,
        end: start + duration,
        text
      })
    }
  }

  return segments
}

