// Vercel Serverless Function for fetching YouTube transcripts

export const config = {
  runtime: 'edge',
}

export default async function handler(request) {
  const url = new URL(request.url)
  const videoId = url.pathname.split('/').pop()

  // Handle OPTIONS for CORS preflight
  if (request.method === 'OPTIONS') {
    return new Response(null, { status: 200, headers: corsHeaders() })
  }

  if (!videoId || videoId.length !== 11) {
    return new Response(
      JSON.stringify({ error: 'Invalid video ID' }),
      { status: 400, headers: corsHeaders() }
    )
  }

  try {
    console.log(`Fetching transcript for: ${videoId}`)
    
    // Get video info
    const videoInfo = await fetchVideoInfo(videoId)

    // Try to get transcript
    const transcript = await fetchTranscript(videoId)

    if (!transcript || transcript.length === 0) {
      return new Response(
        JSON.stringify({ 
          error: 'No transcript available for this video',
          videoId,
          ...videoInfo,
          debug: 'Transcript array was empty after extraction'
        }),
        { status: 404, headers: corsHeaders() }
      )
    }

    console.log(`Success: ${transcript.length} segments for ${videoId}`)

    return new Response(
      JSON.stringify({
        videoId,
        ...videoInfo,
        language: 'en',
        isAutoGenerated: true,
        transcript
      }),
      { status: 200, headers: corsHeaders() }
    )

  } catch (error) {
    console.error('Transcript fetch error:', error)
    return new Response(
      JSON.stringify({ 
        error: error.message || 'Failed to fetch transcript',
        videoId,
        debug: error.stack
      }),
      { status: 500, headers: corsHeaders() }
    )
  }
}

function corsHeaders() {
  return {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
  }
}

async function fetchVideoInfo(videoId) {
  try {
    const response = await fetch(
      `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`
    )
    if (response.ok) {
      const data = await response.json()
      return {
        title: data.title,
        author: data.author_name,
        authorUrl: data.author_url,
        thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`
      }
    }
  } catch (e) {
    console.warn('Failed to fetch video info:', e)
  }
  return {
    title: `Video ${videoId}`,
    author: 'Unknown',
    thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`
  }
}

async function fetchTranscript(videoId) {
  const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`
  
  const response = await fetch(videoPageUrl, {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      'Accept-Language': 'en-US,en;q=0.5',
      'Accept-Encoding': 'gzip, deflate, br',
      'Connection': 'keep-alive',
      'Upgrade-Insecure-Requests': '1',
      'Sec-Fetch-Dest': 'document',
      'Sec-Fetch-Mode': 'navigate',
      'Sec-Fetch-Site': 'none',
      'Sec-Fetch-User': '?1',
    }
  })
  
  if (!response.ok) {
    throw new Error(`Failed to fetch video page: ${response.status}`)
  }

  const html = await response.text()
  
  // Method 1: Look for captionTracks in ytInitialPlayerResponse
  let captionUrl = null
  
  // Try multiple patterns to find caption URL
  const patterns = [
    // Pattern 1: captionTracks array
    /"captionTracks":\s*\[\s*\{[^}]*"baseUrl":\s*"([^"]+)"/,
    // Pattern 2: playerCaptionsTracklistRenderer
    /playerCaptionsTracklistRenderer.*?"captionTracks":\s*\[\s*\{[^}]*"baseUrl":\s*"([^"]+)"/s,
    // Pattern 3: Look for timedtext URL directly
    /"(https:\/\/www\.youtube\.com\/api\/timedtext[^"]+)"/,
    // Pattern 4: Different format
    /captionTracks.*?baseUrl.*?"(https:[^"]+timedtext[^"]+)"/s,
  ]

  for (const pattern of patterns) {
    const match = html.match(pattern)
    if (match) {
      captionUrl = match[1]
        .replace(/\\u0026/g, '&')
        .replace(/\\"/g, '"')
        .replace(/\\\//g, '/')
      console.log(`Found caption URL with pattern: ${pattern.toString().substring(0, 50)}...`)
      break
    }
  }

  // If no URL found, try to extract from ytInitialPlayerResponse JSON
  if (!captionUrl) {
    const playerResponseMatch = html.match(/ytInitialPlayerResponse\s*=\s*(\{.+?\});/)
    if (playerResponseMatch) {
      try {
        const playerData = JSON.parse(playerResponseMatch[1])
        const captions = playerData?.captions?.playerCaptionsTracklistRenderer?.captionTracks
        if (captions && captions.length > 0) {
          // Prefer English, fall back to first available
          const englishTrack = captions.find(t => t.languageCode === 'en' || t.languageCode?.startsWith('en'))
          captionUrl = (englishTrack || captions[0]).baseUrl
          console.log('Found caption URL from JSON parse')
        }
      } catch (e) {
        console.warn('Failed to parse ytInitialPlayerResponse:', e.message)
      }
    }
  }

  if (!captionUrl) {
    // Check if captions are disabled
    if (html.includes('"playabilityStatus":{"status":"ERROR"')) {
      throw new Error('Video is unavailable')
    }
    if (html.includes('"captions":{}') || !html.includes('captionTracks')) {
      throw new Error('No captions available - video may not have transcripts enabled')
    }
    throw new Error('Could not find caption URL in video page')
  }

  // Fetch the caption XML/JSON
  console.log(`Fetching captions from: ${captionUrl.substring(0, 100)}...`)
  
  const captionResponse = await fetch(captionUrl, {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    }
  })
  
  if (!captionResponse.ok) {
    throw new Error(`Failed to fetch captions: ${captionResponse.status}`)
  }

  const captionData = await captionResponse.text()
  
  // Check if it's XML or JSON
  if (captionData.trim().startsWith('<?xml') || captionData.trim().startsWith('<')) {
    return parseTranscriptXml(captionData)
  } else if (captionData.trim().startsWith('{') || captionData.trim().startsWith('[')) {
    return parseTranscriptJson(captionData)
  } else {
    // Try XML parsing anyway
    return parseTranscriptXml(captionData)
  }
}

function parseTranscriptXml(xml) {
  const segments = []
  
  // Parse <text start="..." dur="...">content</text> elements
  const textRegex = /<text[^>]*start="([^"]+)"[^>]*dur="([^"]+)"[^>]*>([^<]*(?:<[^/][^<]*)*)<\/text>/g
  let match

  while ((match = textRegex.exec(xml)) !== null) {
    const start = parseFloat(match[1])
    const duration = parseFloat(match[2])
    let text = match[3]
    
    // Decode HTML entities and clean up
    text = decodeHtmlEntities(text)
      .replace(/<[^>]+>/g, '') // Remove any HTML tags
      .replace(/\n/g, ' ')
      .trim()

    if (text) {
      segments.push({
        start,
        duration,
        end: start + duration,
        text
      })
    }
  }

  // If no matches with dur, try simpler pattern
  if (segments.length === 0) {
    const simpleRegex = /<text[^>]*start="([^"]+)"[^>]*>([^<]+)<\/text>/g
    while ((match = simpleRegex.exec(xml)) !== null) {
      const start = parseFloat(match[1])
      let text = decodeHtmlEntities(match[2]).trim()
      
      if (text) {
        segments.push({
          start,
          duration: 5,
          end: start + 5,
          text
        })
      }
    }
  }

  return segments
}

function parseTranscriptJson(jsonStr) {
  try {
    const data = JSON.parse(jsonStr)
    const segments = []
    
    // Handle various JSON formats YouTube might return
    const events = data.events || data.transcript || data
    
    if (Array.isArray(events)) {
      for (const event of events) {
        if (event.segs) {
          const text = event.segs.map(s => s.utf8).join('').trim()
          if (text) {
            segments.push({
              start: (event.tStartMs || 0) / 1000,
              duration: (event.dDurationMs || 5000) / 1000,
              end: ((event.tStartMs || 0) + (event.dDurationMs || 5000)) / 1000,
              text
            })
          }
        } else if (event.text) {
          segments.push({
            start: event.start || 0,
            duration: event.duration || 5,
            end: (event.start || 0) + (event.duration || 5),
            text: event.text
          })
        }
      }
    }
    
    return segments
  } catch (e) {
    console.error('Failed to parse JSON transcript:', e)
    return []
  }
}

function decodeHtmlEntities(text) {
  return text
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&#(\d+);/g, (_, num) => String.fromCharCode(num))
    .replace(/&#x([a-fA-F0-9]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)))
}
