// Vercel Serverless Function for fetching YouTube transcripts
// Uses YouTube's internal transcript API directly

export const config = {
  runtime: 'edge',
}

export default async function handler(request) {
  const url = new URL(request.url)
  const videoId = url.pathname.split('/').pop()

  if (request.method === 'OPTIONS') {
    return new Response(null, { status: 200, headers: corsHeaders() })
  }

  if (!videoId || videoId.length !== 11) {
    return new Response(
      JSON.stringify({ error: 'Invalid video ID' }),
      { status: 400, headers: corsHeaders() }
    )
  }

  try {
    console.log(`Fetching transcript for: ${videoId}`)
    
    const videoInfo = await fetchVideoInfo(videoId)
    const transcript = await fetchTranscriptDirect(videoId)

    if (!transcript || transcript.length === 0) {
      return new Response(
        JSON.stringify({ 
          error: 'No transcript available for this video',
          videoId,
          ...videoInfo
        }),
        { status: 404, headers: corsHeaders() }
      )
    }

    console.log(`Success: ${transcript.length} segments for ${videoId}`)

    return new Response(
      JSON.stringify({
        videoId,
        ...videoInfo,
        language: 'en',
        isAutoGenerated: true,
        transcript
      }),
      { status: 200, headers: corsHeaders() }
    )

  } catch (error) {
    console.error('Transcript fetch error:', error.message)
    return new Response(
      JSON.stringify({ 
        error: error.message || 'Failed to fetch transcript',
        videoId
      }),
      { status: 500, headers: corsHeaders() }
    )
  }
}

function corsHeaders() {
  return {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
  }
}

async function fetchVideoInfo(videoId) {
  try {
    const response = await fetch(
      `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`
    )
    if (response.ok) {
      const data = await response.json()
      return {
        title: data.title,
        author: data.author_name,
        authorUrl: data.author_url,
        thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`
      }
    }
  } catch (e) {
    console.warn('Failed to fetch video info:', e)
  }
  return {
    title: `Video ${videoId}`,
    author: 'Unknown',
    thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`
  }
}

// Direct approach: fetch video page to get the serialized player response, 
// then extract transcript params and fetch transcript
async function fetchTranscriptDirect(videoId) {
  // Step 1: Get the video page to extract necessary tokens
  const videoPageResponse = await fetch(`https://www.youtube.com/watch?v=${videoId}`, {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Accept-Language': 'en-US,en;q=0.9',
      'Accept': 'text/html,application/xhtml+xml',
    }
  })

  if (!videoPageResponse.ok) {
    throw new Error(`Failed to fetch video page: ${videoPageResponse.status}`)
  }

  const html = await videoPageResponse.text()

  // Try Method 1: Direct timedtext URL from page
  const timedtextResult = await tryTimedtextMethod(html)
  if (timedtextResult && timedtextResult.length > 0) {
    return timedtextResult
  }

  // Try Method 2: YouTube's internal transcript API
  const internalApiResult = await tryInternalApiMethod(html, videoId)
  if (internalApiResult && internalApiResult.length > 0) {
    return internalApiResult
  }

  throw new Error('Could not retrieve transcript - no captions found')
}

async function tryTimedtextMethod(html) {
  // Look for timedtext URL in the page
  const patterns = [
    /"baseUrl"\s*:\s*"(https:\\\/\\\/www\.youtube\.com\\\/api\\\/timedtext[^"]+)"/,
    /"baseUrl":"(https:\/\/www\.youtube\.com\/api\/timedtext[^"]+)"/,
    /timedtext[^"]*v=([^"&]+)[^"]*"/,
  ]

  for (const pattern of patterns) {
    const match = html.match(pattern)
    if (match) {
      let url = match[1]
      // Unescape the URL
      url = url
        .replace(/\\u0026/g, '&')
        .replace(/\\\//g, '/')
        .replace(/\\"/g, '"')

      try {
        const response = await fetch(url, {
          headers: { 'User-Agent': 'Mozilla/5.0' }
        })
        if (response.ok) {
          const data = await response.text()
          if (data.includes('<text')) {
            return parseXmlTranscript(data)
          }
        }
      } catch (e) {
        console.warn('Timedtext fetch failed:', e.message)
      }
    }
  }
  return null
}

async function tryInternalApiMethod(html, videoId) {
  // Extract the params needed for the transcript API
  // Look for the transcript panel params in ytInitialData
  
  // Find engagement panels with transcript
  const panelMatch = html.match(/"engagementPanels":\s*(\[[\s\S]*?\])\s*,\s*"topbar"/)
  if (!panelMatch) {
    // Try alternative: look for serializedShareEntity or other markers
    const transcriptMatch = html.match(/"params"\s*:\s*"([^"]+)"[^}]*"transcriptSearchPanel"/)
    if (transcriptMatch) {
      return await fetchTranscriptFromParams(transcriptMatch[1], videoId)
    }
    return null
  }

  try {
    // Find transcript params in engagement panels
    const paramsMatch = html.match(/"transcriptEndpoint"\s*:\s*\{[^}]*"params"\s*:\s*"([^"]+)"/)
    if (paramsMatch) {
      return await fetchTranscriptFromParams(paramsMatch[1], videoId)
    }
  } catch (e) {
    console.warn('Internal API method failed:', e.message)
  }

  return null
}

async function fetchTranscriptFromParams(params, videoId) {
  // Use YouTube's internal API to fetch transcript
  const apiUrl = 'https://www.youtube.com/youtubei/v1/get_transcript'
  
  const body = {
    context: {
      client: {
        clientName: 'WEB',
        clientVersion: '2.20231219.04.00',
        hl: 'en',
        gl: 'US',
      }
    },
    params: params
  }

  try {
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      },
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return parseInternalApiResponse(data)
    }
  } catch (e) {
    console.warn('Transcript API call failed:', e.message)
  }

  return null
}

function parseInternalApiResponse(data) {
  const segments = []
  
  // Navigate the response structure
  const actions = data?.actions || []
  for (const action of actions) {
    const transcriptRenderer = action?.updateEngagementPanelAction?.content?.transcriptRenderer
    const body = transcriptRenderer?.content?.transcriptSearchPanelRenderer?.body
    const segmentList = body?.transcriptSegmentListRenderer?.initialSegments || 
                        transcriptRenderer?.body?.transcriptSegmentListRenderer?.initialSegments || []

    for (const segment of segmentList) {
      const seg = segment?.transcriptSegmentRenderer
      if (seg) {
        const startMs = parseInt(seg.startMs || '0')
        const endMs = parseInt(seg.endMs || '0')
        const text = seg.snippet?.runs?.map(r => r.text).join('') || ''
        
        if (text.trim()) {
          segments.push({
            start: startMs / 1000,
            duration: (endMs - startMs) / 1000,
            end: endMs / 1000,
            text: text.trim()
          })
        }
      }
    }
  }

  // Also try direct transcript body
  if (segments.length === 0 && data?.body?.transcriptBodyRenderer?.cueGroups) {
    for (const group of data.body.transcriptBodyRenderer.cueGroups) {
      const cue = group?.transcriptCueGroupRenderer?.cues?.[0]?.transcriptCueRenderer
      if (cue) {
        const startMs = parseInt(cue.startOffsetMs || '0')
        const durationMs = parseInt(cue.durationMs || '5000')
        const text = cue.cue?.simpleText || cue.cue?.runs?.map(r => r.text).join('') || ''
        
        if (text.trim()) {
          segments.push({
            start: startMs / 1000,
            duration: durationMs / 1000,
            end: (startMs + durationMs) / 1000,
            text: text.trim()
          })
        }
      }
    }
  }

  return segments
}

function parseXmlTranscript(xml) {
  const segments = []
  const regex = /<text[^>]*start="([\d.]+)"[^>]*(?:dur="([\d.]+)")?[^>]*>([\s\S]*?)<\/text>/gi
  let match

  while ((match = regex.exec(xml)) !== null) {
    const start = parseFloat(match[1])
    const duration = match[2] ? parseFloat(match[2]) : 5
    let text = match[3]
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/<[^>]+>/g, '')
      .replace(/\s+/g, ' ')
      .trim()

    if (text) {
      segments.push({
        start,
        duration,
        end: start + duration,
        text
      })
    }
  }

  return segments
}
