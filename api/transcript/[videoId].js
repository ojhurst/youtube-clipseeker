// Vercel Serverless Function for fetching YouTube transcripts

export const config = {
  runtime: 'edge',
}

export default async function handler(request) {
  const url = new URL(request.url)
  const videoId = url.pathname.split('/').pop()

  if (request.method === 'OPTIONS') {
    return new Response(null, { status: 200, headers: corsHeaders() })
  }

  if (!videoId || videoId.length !== 11) {
    return new Response(
      JSON.stringify({ error: 'Invalid video ID' }),
      { status: 400, headers: corsHeaders() }
    )
  }

  try {
    console.log(`Fetching transcript for: ${videoId}`)
    
    const videoInfo = await fetchVideoInfo(videoId)
    const transcript = await fetchTranscript(videoId)

    if (!transcript || transcript.length === 0) {
      return new Response(
        JSON.stringify({ 
          error: 'No transcript available for this video',
          videoId,
          ...videoInfo
        }),
        { status: 404, headers: corsHeaders() }
      )
    }

    console.log(`Success: ${transcript.length} segments for ${videoId}`)

    return new Response(
      JSON.stringify({
        videoId,
        ...videoInfo,
        language: 'en',
        isAutoGenerated: true,
        transcript
      }),
      { status: 200, headers: corsHeaders() }
    )

  } catch (error) {
    console.error('Transcript fetch error:', error)
    return new Response(
      JSON.stringify({ 
        error: error.message || 'Failed to fetch transcript',
        videoId
      }),
      { status: 500, headers: corsHeaders() }
    )
  }
}

function corsHeaders() {
  return {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
  }
}

async function fetchVideoInfo(videoId) {
  try {
    const response = await fetch(
      `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`
    )
    if (response.ok) {
      const data = await response.json()
      return {
        title: data.title,
        author: data.author_name,
        authorUrl: data.author_url,
        thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`
      }
    }
  } catch (e) {
    console.warn('Failed to fetch video info:', e)
  }
  return {
    title: `Video ${videoId}`,
    author: 'Unknown',
    thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`
  }
}

async function fetchTranscript(videoId) {
  const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`
  
  const response = await fetch(videoPageUrl, {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      'Accept-Language': 'en-US,en;q=0.5',
    }
  })
  
  if (!response.ok) {
    throw new Error(`Failed to fetch video page: ${response.status}`)
  }

  const html = await response.text()
  
  // Simple and direct: find the timedtext URL
  // Look for: "baseUrl":"https://www.youtube.com/api/timedtext?...
  const timedtextMatch = html.match(/"baseUrl"\s*:\s*"(https:\/\/www\.youtube\.com\/api\/timedtext[^"]+)"/i)
  
  if (!timedtextMatch) {
    // Try alternative: look in captionTracks
    const captionTracksMatch = html.match(/"captionTracks"\s*:\s*\[([\s\S]*?)\]/)
    if (captionTracksMatch) {
      const tracksContent = captionTracksMatch[1]
      const urlMatch = tracksContent.match(/"baseUrl"\s*:\s*"([^"]+)"/)
      if (urlMatch) {
        const captionUrl = urlMatch[1]
          .replace(/\\u0026/g, '&')
          .replace(/\\\//g, '/')
        return await fetchAndParseCaptions(captionUrl)
      }
    }
    
    // Check if video exists but has no captions
    if (html.includes('"playabilityStatus"') && !html.includes('captionTracks')) {
      throw new Error('This video does not have captions available')
    }
    
    throw new Error('Could not find caption URL')
  }

  // Clean up the URL (unescape unicode)
  const captionUrl = timedtextMatch[1]
    .replace(/\\u0026/g, '&')
    .replace(/\\\//g, '/')
  
  return await fetchAndParseCaptions(captionUrl)
}

async function fetchAndParseCaptions(captionUrl) {
  console.log(`Fetching captions from: ${captionUrl.substring(0, 80)}...`)
  
  const response = await fetch(captionUrl, {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    }
  })
  
  if (!response.ok) {
    throw new Error(`Failed to fetch captions: ${response.status}`)
  }

  const data = await response.text()
  
  // Try XML parsing first (most common)
  if (data.includes('<text')) {
    return parseTranscriptXml(data)
  }
  
  // Try JSON parsing
  if (data.trim().startsWith('{') || data.trim().startsWith('[')) {
    return parseTranscriptJson(data)
  }
  
  // Fallback to XML parsing
  return parseTranscriptXml(data)
}

function parseTranscriptXml(xml) {
  const segments = []
  
  // Match <text start="X" dur="Y">content</text>
  const regex = /<text[^>]*start="([\d.]+)"[^>]*(?:dur="([\d.]+)")?[^>]*>([\s\S]*?)<\/text>/gi
  let match

  while ((match = regex.exec(xml)) !== null) {
    const start = parseFloat(match[1])
    const duration = match[2] ? parseFloat(match[2]) : 5
    let text = match[3]
    
    // Decode HTML entities
    text = decodeEntities(text)
      .replace(/<[^>]+>/g, '')
      .replace(/\s+/g, ' ')
      .trim()

    if (text) {
      segments.push({
        start,
        duration,
        end: start + duration,
        text
      })
    }
  }

  return segments
}

function parseTranscriptJson(jsonStr) {
  try {
    const data = JSON.parse(jsonStr)
    const segments = []
    const events = data.events || data.transcript || data
    
    if (Array.isArray(events)) {
      for (const event of events) {
        if (event.segs) {
          const text = event.segs.map(s => s.utf8 || '').join('').trim()
          if (text) {
            segments.push({
              start: (event.tStartMs || 0) / 1000,
              duration: (event.dDurationMs || 5000) / 1000,
              end: ((event.tStartMs || 0) + (event.dDurationMs || 5000)) / 1000,
              text
            })
          }
        }
      }
    }
    
    return segments
  } catch (e) {
    console.error('JSON parse error:', e)
    return []
  }
}

function decodeEntities(text) {
  return text
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&#(\d+);/g, (_, n) => String.fromCharCode(n))
    .replace(/&#x([a-fA-F0-9]+);/g, (_, h) => String.fromCharCode(parseInt(h, 16)))
}
